# 知识图谱系统服务器部署优化方案

## 📊 当前系统状态评估

### 数据规模分析
- **图数据库**: 4,432个节点，17,412个关系
- **上传文件**: 39.88 MB
- **缓存数据**: 25.12 MB
- **总数据量**: ~65 MB (中等规模)

### 系统性能现状
- **CPU使用率**: 3.1% (良好)
- **内存使用**: 48.4% (正常)
- **磁盘使用**: 8.3% (充足)
- **API响应时间**: 2-2.2秒 (需要优化)

## 🏗️ 优化存储架构设计

### 三层存储架构

#### 🔥 热数据层 (毫秒级响应)
```
技术栈: Redis + 内存缓存
数据类型:
- 用户会话数据
- API响应缓存
- 实时统计数据
- 频繁查询结果

配置建议:
- Redis内存: 2-4GB
- 缓存策略: LRU
- 持久化: RDB + AOF
```

#### 🌡️ 温数据层 (秒级响应)
```
技术栈: Neo4j + PostgreSQL
数据类型:
- 词典和本体数据
- 图谱节点和关系
- 用户和权限数据
- 业务配置数据

配置建议:
- Neo4j堆内存: 4GB
- 页缓存: 2GB
- PostgreSQL: 用于结构化数据
```

#### ❄️ 冷数据层 (分钟级响应)
```
技术栈: 对象存储(S3/OSS/MinIO) + 文件系统
数据类型:
- 历史上传文件
- 系统日志文件
- 数据备份文件
- 导出的报告文件

配置建议:
- 生命周期管理
- 自动归档策略
- 压缩存储
```

## 🐳 容器化部署方案

### Docker Compose 生产配置

```yaml
version: '3.8'

services:
  # Neo4j 图数据库
  neo4j:
    image: neo4j:5.23
    container_name: kg_neo4j_prod
    environment:
      - NEO4J_AUTH=neo4j/your_secure_password_here
      - NEO4J_server_memory_heap_initial__size=2g
      - NEO4J_server_memory_heap_max__size=4g
      - NEO4J_server_memory_pagecache_size=2g
      - NEO4J_server_bolt_thread__pool__min__size=5
      - NEO4J_server_bolt_thread__pool__max__size=400
    ports:
      - "7474:7474"
      - "7687:7687"
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
      - ./config/neo4j.conf:/var/lib/neo4j/conf/neo4j.conf
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "cypher-shell", "-u", "neo4j", "-p", "your_secure_password_here", "RETURN 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Redis 缓存
  redis:
    image: redis:7-alpine
    container_name: kg_redis_prod
    command: redis-server --appendonly yes --maxmemory 2gb --maxmemory-policy allkeys-lru
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # API 服务
  api:
    build: 
      context: ./api
      dockerfile: Dockerfile.prod
    container_name: kg_api_prod
    environment:
      - ENV=production
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASS=your_secure_password_here
      - REDIS_URL=redis://redis:6379
      - LOG_LEVEL=INFO
    ports:
      - "8000:8000"
    volumes:
      - ./data:/app/data:ro
      - uploads_data:/app/uploads
    depends_on:
      neo4j:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    container_name: kg_nginx_prod
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - ./dist:/usr/share/nginx/html:ro
      - nginx_logs:/var/log/nginx
    depends_on:
      - api
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3

  # MinIO 对象存储 (可选)
  minio:
    image: minio/minio:latest
    container_name: kg_minio_prod
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=admin
      - MINIO_ROOT_PASSWORD=your_minio_password_here
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  neo4j_data:
  neo4j_logs:
  redis_data:
  uploads_data:
  minio_data:
  nginx_logs:

networks:
  default:
    driver: bridge
```

## ⚡ 性能优化配置

### Neo4j 生产环境配置
```properties
# 内存配置
server.memory.heap.initial_size=2g
server.memory.heap.max_size=4g
server.memory.pagecache.size=2g

# 连接配置
server.bolt.thread_pool_min_size=5
server.bolt.thread_pool_max_size=400
server.bolt.connection_keep_alive=60s

# 查询优化
cypher.default_language_version=5
cypher.hints_error=true
cypher.lenient_create_relationship=false

# 事务配置
db.transaction.timeout=60s
db.transaction.bookmark_ready_timeout=30s

# 安全配置
server.default_listen_address=0.0.0.0
server.bolt.listen_address=:7687
server.http.listen_address=:7474

# 日志配置
server.logs.user.stdout_enabled=true
server.logs.debug.level=WARN
```

### Nginx 生产环境配置
```nginx
upstream api_backend {
    server api:8000;
    keepalive 32;
}

# HTTP重定向到HTTPS
server {
    listen 80;
    server_name your-domain.com;
    return 301 https://$server_name$request_uri;
}

# HTTPS主配置
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSL配置
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # 安全头
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    
    # 前端静态文件
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
        
        # 静态资源缓存
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            gzip_static on;
        }
    }
    
    # API代理
    location /api/ {
        proxy_pass http://api_backend/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # 超时配置
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
        
        # 缓存配置
        proxy_cache api_cache;
        proxy_cache_valid 200 5m;
        proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
    }
}

# 缓存配置
proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=api_cache:10m max_size=100m inactive=60m use_temp_path=off;
```

## 🔄 数据迁移策略

### 阶段1: 数据备份
```bash
# 1. Neo4j数据备份
neo4j-admin dump --database=neo4j --to=/backup/neo4j_$(date +%Y%m%d).dump

# 2. 应用数据备份
tar -czf /backup/app_data_$(date +%Y%m%d).tar.gz data/ config/ api/uploads/

# 3. 验证备份完整性
sha256sum /backup/* > /backup/checksums.txt
```

### 阶段2: 环境准备
```bash
# 1. 安装Docker和Docker Compose
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# 2. 配置防火墙
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw allow 22/tcp
sudo ufw enable

# 3. 创建数据目录
sudo mkdir -p /opt/kg/{data,logs,backup,ssl}
sudo chown -R $USER:$USER /opt/kg
```

### 阶段3: 数据迁移
```bash
# 1. 恢复Neo4j数据
docker-compose exec neo4j neo4j-admin load --from=/backup/neo4j_backup.dump --database=neo4j --force

# 2. 恢复应用数据
tar -xzf app_data_backup.tar.gz -C /opt/kg/

# 3. 启动服务
docker-compose up -d

# 4. 验证服务
docker-compose ps
curl -f http://localhost/api/health
```

## 📊 监控和告警

### 监控指标
```yaml
系统监控:
  - CPU使用率 (告警阈值: >80%)
  - 内存使用率 (告警阈值: >85%)
  - 磁盘使用率 (告警阈值: >90%)
  - 网络IO (告警阈值: >100MB/s)

应用监控:
  - API响应时间 (告警阈值: >2秒)
  - 错误率 (告警阈值: >5%)
  - 并发连接数 (告警阈值: >1000)
  - 数据库连接池 (告警阈值: >80%)

业务监控:
  - 图谱查询性能
  - 数据导入成功率
  - 用户活跃度
  - 存储增长趋势
```

### 日志管理
```yaml
日志类型:
  - 应用日志: JSON格式，包含请求ID
  - 访问日志: Nginx格式，记录所有请求
  - 错误日志: 详细堆栈信息
  - 审计日志: 用户操作记录

日志策略:
  - 保留期: 30天
  - 轮转: 每日轮转
  - 压缩: gzip压缩
  - 聚合: ELK Stack或类似方案
```

## 🔒 安全加固

### 网络安全
- 使用HTTPS (TLS 1.2+)
- 配置防火墙规则
- 限制数据库访问
- API速率限制

### 数据安全
- 数据库密码加密
- 敏感数据脱敏
- 定期安全备份
- 访问权限控制

### 应用安全
- JWT认证
- CORS配置
- 输入验证
- SQL注入防护

## 🎯 部署检查清单

### 部署前检查
- [ ] 服务器资源充足 (CPU: 4核+, 内存: 8GB+, 磁盘: 100GB+)
- [ ] 域名和SSL证书准备
- [ ] 数据备份完成并验证
- [ ] 配置文件准备完成
- [ ] 监控系统部署完成

### 部署后验证
- [ ] 所有服务正常启动
- [ ] 健康检查通过
- [ ] 数据迁移验证
- [ ] 性能基准测试
- [ ] 安全扫描通过

### 上线后监控
- [ ] 监控告警配置
- [ ] 日志聚合正常
- [ ] 备份策略执行
- [ ] 性能指标正常
- [ ] 用户访问正常

## 💡 优化建议总结

1. **立即优化**: 
   - 实施Redis缓存
   - 优化API响应时间
   - 配置Nginx反向代理

2. **中期优化**:
   - 容器化部署
   - 实施监控告警
   - 数据分层存储

3. **长期优化**:
   - 微服务架构
   - 自动扩缩容
   - 多地域部署

这个优化方案将显著提升系统的性能、可靠性和可维护性，为生产环境部署做好充分准备。
